name: SWAIF Factory

on:
  issues:
    types: [labeled]
  workflow_dispatch:
    inputs:
      stage:
        description: SWAIF stage to run
        required: true
        type: choice
        options:
          - init
          - specify
          - plan
          - tasks
          - implement
          - verify
      feature_slug:
        description: Feature slug (kebab-case)
        required: true
        type: string
      declared_execution_type:
        description: Declared Execution Type
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write
  repository-projects: write

concurrency:
  group: swaif-factory-issues-${{ github.event.issue.number }}-${{ github.event.label.name }}
  cancel-in-progress: true

jobs:
  run-stage:
    if: >-
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issues' &&
      (github.event.label.name == 'swaif:init' ||
       github.event.label.name == 'swaif:specify' ||
       github.event.label.name == 'swaif:plan' ||
       github.event.label.name == 'swaif:tasks' ||
       github.event.label.name == 'swaif:implement' ||
       github.event.label.name == 'swaif:verify'))
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      PROJECT_NUMBER: 2

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Configure git identity (required for commits)
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Resolve stage and metadata
        id: meta
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_SECRET }}
          script: |
            const eventName = context.eventName;
            let stage = '';
            let featureSlug = '';
            let executionType = '';
            let overview = '';
            let problemStatement = '';
            let scope = '';
            let acceptanceCriteria = '';
            let constraints = '';
            let nonGoals = '';
            let issueNumber = '';
            const allowedStages = new Set(['init','specify', 'plan', 'tasks', 'implement', 'verify']);

            if (eventName === 'workflow_dispatch') {
              stage = core.getInput('stage').trim();
              featureSlug = core.getInput('feature_slug').trim();
              executionType = core.getInput('declared_execution_type').trim();
              issueNumber = '0';
            } else {
              const issue = context.payload.issue;
              issueNumber = String(issue.number);
              const label = context.payload.label?.name || '';
              stage = label.replace('swaif:', '').trim();

              const body = issue.body || '';
              const readHeading = (heading) => {
                const pattern = new RegExp(`^### ${heading}\\s*$\\n([\\s\\S]*?)(?=^### |$)`, 'm');
                const match = body.match(pattern);
                if (!match) return '';
                const value = match[1]
                  .split('\n')
                  .map((line) => line.trim())
                  .find((line) => line.length > 0 && line !== '_No response_');
                return value || '';
              };

              featureSlug = readHeading('Feature Slug');
              executionType = readHeading('Declared Execution Type');
              overview = readHeading('Overview');
              problemStatement = readHeading('Problem Statement');
              scope = readHeading('Scope');
              acceptanceCriteria = readHeading('Acceptance Criteria');
              constraints = readHeading('Constraints');
              nonGoals = readHeading('Non-Goals');

              const missingRequiredSections = [];
              if (!featureSlug) missingRequiredSections.push('### Feature Slug');
              if (!executionType) missingRequiredSections.push('### Declared Execution Type');
              if (!overview) missingRequiredSections.push('### Overview');
              if (!problemStatement) missingRequiredSections.push('### Problem Statement');
              if (!scope) missingRequiredSections.push('### Scope');
              if (!acceptanceCriteria) missingRequiredSections.push('### Acceptance Criteria');
              if (!constraints) missingRequiredSections.push('### Constraints');
              if (!nonGoals) missingRequiredSections.push('### Non-Goals');

              if (missingRequiredSections.length > 0) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: [
                    'Missing required metadata for SWAIF automation.',
                    '',
                    'Please edit the issue body and provide values directly under:',
                    ...missingRequiredSections.map((heading) => `- \`${heading}\``),
                    '',
                    'Then re-apply one stage label: `swaif:specify`, `swaif:plan`, `swaif:tasks`, `swaif:implement`, or `swaif:verify`.'
                  ].join('\n')
                });
                core.setFailed('Issue metadata missing.');
                return;
              }
            }

            if (!allowedStages.has(stage)) {
              core.setFailed(`Invalid stage '${stage}'. Must be exactly one of: specify, plan, tasks, implement, verify.`);
              return;
            }

            if (!/^[a-z0-9][a-z0-9-]*$/.test(featureSlug)) {
              core.setFailed(`Invalid feature_slug '${featureSlug}'. Expected kebab-case.`);
              return;
            }

            core.setOutput('stage', stage);
            core.setOutput('feature_slug', featureSlug);
            core.setOutput('execution_type', executionType);
            core.setOutput('issue_number', issueNumber);

      - name: On cancellation cleanup
        if: cancelled() && github.event_name == 'issues'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_SECRET }}
          script: |
            const issue = context.payload.issue;
            if (!issue) return;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: '‚ö†Ô∏è **SWAIF workflow was manually cancelled.** Re-apply the stage label when ready to retry.'
            });

      - name: Clean up stage labels
        if: github.event_name == 'issues'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_SECRET }}
          script: |
            const issue = context.payload.issue;
            if (!issue) return;
            const labelsToRemove = [
              'swaif:specify', 'swaif:plan', 'swaif:tasks',
              'swaif:implement', 'swaif:verify', 'swaif:blocked'
            ];
            const currentLabel = context.payload.label?.name || '';
            const existing = issue.labels.map((l) => l.name);
            for (const label of labelsToRemove) {
              // Keep the label that was just applied; remove all others
              if (label !== currentLabel && existing.includes(label)) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: label
                  });
                } catch (err) {
                  // Label may have already been removed; continue
                  console.log(`Could not remove label '${label}': ${err.message}`);
                }
              }
            }

      - name: Run one SWAIF stage
        shell: bash
        run: |
          set -euo pipefail
          log_dir=".swaif/logs"
          mkdir -p "$log_dir"
          log_file="${log_dir}/swaif-stage-${{ steps.meta.outputs.stage }}-issue-${{ steps.meta.outputs.issue_number }}-run-${{ github.run_id }}-attempt-${{ github.run_attempt }}.log"

          {
            echo "=== SWAIF Stage Execution Log ==="
            echo "timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            echo "repo=${{ github.repository }}"
            echo "run_id=${{ github.run_id }}"
            echo "run_attempt=${{ github.run_attempt }}"
            echo "issue_number=${{ steps.meta.outputs.issue_number }}"
            echo "stage=${{ steps.meta.outputs.stage }}"
            echo "feature_slug=${{ steps.meta.outputs.feature_slug }}"
            echo "execution_type=${{ steps.meta.outputs.execution_type }}"
            echo

              # Adapted: Use SpecKit CLI for stage control as in speckit-wf.yml
              if [[ "${{ steps.meta.outputs.stage }}" == "init" ]]; then
                echo " Installing SpecKit..."
                npm install -g @github/spec-kit
                echo " Testing which CLI to use speckit:"
                specify --version || speckit --version || specify -h || speckit -h
              elif [[ "${{ steps.meta.outputs.stage }}" == "specify" ]]; then
                specify generate --config path/to/constitution.yaml
              elif [[ "${{ steps.meta.outputs.stage }}" == "plan" ]]; then
                specify plan --config path/to/constitution.yaml
              elif [[ "${{ steps.meta.outputs.stage }}" == "tasks" ]]; then
                specify task --config path/to/constitution.yaml
              elif [[ "${{ steps.meta.outputs.stage }}" == "implement" ]]; then
                specify implement --config path/to/constitution.yaml
              elif [[ "${{ steps.meta.outputs.stage }}" == "verify" ]]; then
                echo "Verify stage logic here (customize as needed)"
              else
                echo "Unknown stage: ${{ steps.meta.outputs.stage }}"
                exit 1
              fi
          } 2>&1 | tee -a "$log_file"

      - name: Upload SWAIF stage logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: swaif-logs-${{ steps.meta.outputs.stage }}-issue-${{ steps.meta.outputs.issue_number }}-run-${{ github.run_id }}-attempt-${{ github.run_attempt }}
          path: .swaif/logs/*.log
          if-no-files-found: warn
          retention-days: 14

      - name: Publish log artifact summary
        if: always()
        shell: bash
        run: |
          {
            echo "### SWAIF debug log"
            echo "- Artifact name: \`swaif-logs-${{ steps.meta.outputs.stage }}-issue-${{ steps.meta.outputs.issue_number }}-run-${{ github.run_id }}-attempt-${{ github.run_attempt }}\`"
            echo "- Open the **Artifacts** section in this workflow run and download the .log file."
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Push branch to remote
        run: |
          git push --force-with-lease origin "swaif/${{ steps.meta.outputs.feature_slug }}"

      - name: Create or update PR
        uses: actions/github-script@v7
        env:
          FEATURE_SLUG: ${{ steps.meta.outputs.feature_slug }}
          STAGE: ${{ steps.meta.outputs.stage }}
        with:
          github-token: ${{ secrets.PROJECTS_SECRET }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const headBranch = `swaif/${process.env.FEATURE_SLUG}`; // same-repo head
            const base = 'main';

            // Ensure head ref exists and is readable
            try {
              await github.rest.git.getRef({
                owner,
                repo,
                ref: `heads/${headBranch}`,
              });
              console.log(`Confirmed head branch exists: ${headBranch}`);
            } catch (e) {
              core.setFailed(
                `Head branch '${headBranch}' is not readable/found. ` +
                `Likely the 'git push' step failed or pushed to a different remote. ` +
                `Details: ${e.message}`
              );
              return;
            }

            const title = `SWAIF ${process.env.STAGE}: ${process.env.FEATURE_SLUG}`;
            const body = [
              'Automated SWAIF stage execution.',
              '',
              `- Stage: \`${process.env.STAGE}\``,
              `- Feature: \`${process.env.FEATURE_SLUG}\``,
              '',
              'SWAIF is a Spec-Driven Software Factory where production is stage-gated, traceable, and driven by a Kanban state machine.'
            ].join('\n');

            // Find existing open PR from headBranch -> base
            const prs = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              head: `${owner}:${headBranch}`, // OK for filtering
              base,
            });

            if (prs.data.length > 0) {
              await github.rest.pulls.update({
                owner,
                repo,
                pull_number: prs.data[0].number,
                title,
                body,
              });
              console.log(`Updated PR #${prs.data[0].number}`);
            } else {
              // For creation, use headBranch without owner prefix to avoid "refs not readable"
              await github.rest.pulls.create({
                owner,
                repo,
                head: headBranch,
                base,
                title,
                body,
              });
              console.log(`Created PR from ${headBranch} -> ${base}`);
            }

      - name: Post success comment
        if: github.event_name == 'issues'
        uses: actions/github-script@v7
        env:
          STAGE: ${{ steps.meta.outputs.stage }}
          FEATURE_SLUG: ${{ steps.meta.outputs.feature_slug }}
        with:
          github-token: ${{ secrets.PROJECTS_SECRET }}
          script: |
            const issue = context.payload.issue;
            if (!issue) return;
            const stage = process.env.STAGE;
            const featureSlug = process.env.FEATURE_SLUG;
            const stageEmoji = {
              specify: 'üìã', plan: 'üó∫Ô∏è', tasks: '‚úÖ',
              implement: '‚öôÔ∏è', verify: 'üîç'
            };
            const nextStage = {
              specify: 'plan', plan: 'tasks', tasks: 'implement',
              implement: 'verify', verify: null
            };
            const emoji = stageEmoji[stage] || 'üöÄ';
            const next = nextStage[stage];
            const nextLine = next
              ? `‚û°Ô∏è **Next:** Apply \`swaif:${next}\` to continue.`
              : 'üéâ **All stages complete!** The feature is ready for final review.';
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: [
                `${emoji} **SWAIF stage \`${stage}\` completed successfully** for \`${featureSlug}\`.`,
                '',
                nextLine,
                '',
                '<details><summary>Available stage labels</summary>',
                '',
                '`swaif:specify` ‚Üí `swaif:plan` ‚Üí `swaif:tasks` ‚Üí `swaif:implement` ‚Üí `swaif:verify`',
                '',
                '</details>'
              ].join('\n')
            });

      - name: Update Project Board - Success
        if: github.event_name == 'issues'
        uses: actions/github-script@v7
        env:
          STAGE: ${{ steps.meta.outputs.stage }}
          FEATURE_SLUG: ${{ steps.meta.outputs.feature_slug }}
          EXECUTION_TYPE: ${{ steps.meta.outputs.execution_type }}
        with:
          github-token: ${{ secrets.PROJECTS_SECRET }}
          script: |
            const orgLogin = context.repo.owner;
            const issueNodeId = context.payload.issue?.node_id;
            const projectNumber = parseInt(process.env.PROJECT_NUMBER, 10);
            const stage = process.env.STAGE;
            const featureSlug = process.env.FEATURE_SLUG;
            const executionType = process.env.EXECUTION_TYPE;

            // Map stage names to expected project field option names
            const stageOptionMap = {
              specify: 'Specify', plan: 'Plan', tasks: 'Tasks',
              implement: 'Implement', verify: 'Verify'
            };
            const stageOptionName = stageOptionMap[stage];

            try {
              // Step 1: Query project metadata (ID, field IDs, and single-select options)
              const projectQuery = await github.graphql(`
                query($org: String!, $number: Int!) {
                  organization(login: $org) {
                    projectV2(number: $number) {
                      id
                      fields(first: 20) {
                        nodes {
                          ... on ProjectV2Field {
                            id
                            name
                          }
                          ... on ProjectV2SingleSelectField {
                            id
                            name
                            options { id name }
                          }
                        }
                      }
                    }
                  }
                }
              `, { org: orgLogin, number: projectNumber });

              const project = projectQuery.organization?.projectV2;
              if (!project) {
                console.log(`Project #${projectNumber} not found in org '${orgLogin}'. Skipping board update.`);
                return;
              }
              const projectId = project.id;

              // Resolve field IDs from the project's field list
              let stageFieldId = null, stageOptionId = null;
              let featureSlugFieldId = null, executionTypeFieldId = null;
              for (const field of project.fields.nodes) {
                if (field.name === 'Stage') {
                  stageFieldId = field.id;
                  const opt = (field.options || []).find((o) => o.name === stageOptionName);
                  if (opt) stageOptionId = opt.id;
                } else if (field.name === 'Feature Slug') {
                  featureSlugFieldId = field.id;
                } else if (field.name === 'Execution Type') {
                  executionTypeFieldId = field.id;
                }
              }

              // Step 2: Query current project items for this issue
              const issueQuery = await github.graphql(`
                query($id: ID!) {
                  node(id: $id) {
                    ... on Issue {
                      projectItems(first: 10) {
                        nodes {
                          id
                          project { id }
                        }
                      }
                    }
                  }
                }
              `, { id: issueNodeId });

              // Find existing project item or add the issue to the project
              let itemId = null;
              const items = issueQuery.node?.projectItems?.nodes || [];
              const existing = items.find((item) => item.project.id === projectId);
              if (existing) {
                itemId = existing.id;
                console.log(`Issue already in project, item ID: ${itemId}`);
              } else {
                // Step 3: Add issue to project
                const addResult = await github.graphql(`
                  mutation($projectId: ID!, $contentId: ID!) {
                    addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                      item { id }
                    }
                  }
                `, { projectId, contentId: issueNodeId });
                itemId = addResult.addProjectV2ItemById?.item?.id;
                console.log(`Added issue to project, item ID: ${itemId}`);
              }

              if (!itemId) {
                console.log('Could not obtain project item ID. Skipping field updates.');
                return;
              }

              // Step 4: Update the Stage single-select field
              if (stageFieldId && stageOptionId) {
                await github.graphql(`
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { singleSelectOptionId: $optionId }
                    }) { projectV2Item { id } }
                  }
                `, { projectId, itemId, fieldId: stageFieldId, optionId: stageOptionId });
                console.log(`Stage field updated to '${stageOptionName}'.`);
              } else {
                console.log(`Stage field or option '${stageOptionName}' not found. Skipping.`);
              }

              // Step 5: Update text fields (Feature Slug and Execution Type)
              const textUpdates = [
                { fieldId: featureSlugFieldId, value: featureSlug, label: 'Feature Slug' },
                { fieldId: executionTypeFieldId, value: executionType, label: 'Execution Type' }
              ];
              for (const { fieldId, value, label } of textUpdates) {
                if (!fieldId) {
                  console.log(`'${label}' field not found in project. Skipping.`);
                  continue;
                }
                await github.graphql(`
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $text: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { text: $text }
                    }) { projectV2Item { id } }
                  }
                `, { projectId, itemId, fieldId, text: value });
                console.log(`'${label}' field updated to '${value}'.`);
              }
            } catch (err) {
              // Project update failures must not break the overall workflow
              console.log(`Project board update failed (non-fatal): ${err.message}`);
            }

      - name: On failure add blocked label and guidance
        if: failure() && github.event_name == 'issues'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_SECRET }}
          script: |
            const issue = context.payload.issue;
            const logsUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            if (!issue) return;
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: ['swaif:blocked']
            });
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: [
                'üö´ **SWAIF stage failed** ‚Äî issue marked `swaif:blocked`.',
                '',
                '**Next steps:**',
                `1. üîç Review the [workflow logs](${logsUrl}) to identify the root cause.`,
                '2. üõ†Ô∏è Fix missing prerequisites, issue metadata, or content.',
                '3. üè∑Ô∏è Remove the `swaif:blocked` label.',
                '4. üîÅ Re-apply the intended stage label to retry exactly one step.',
                '',
                '> **Available stage labels:** `swaif:specify` ‚Üí `swaif:plan` ‚Üí `swaif:tasks` ‚Üí `swaif:implement` ‚Üí `swaif:verify`'
              ].join('\n')
            });

      - name: Update Project Board - Blocked
        if: failure() && github.event_name == 'issues'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_SECRET }}
          script: |
            const orgLogin = context.repo.owner;
            const issueNodeId = context.payload.issue?.node_id;
            const projectNumber = parseInt(process.env.PROJECT_NUMBER, 10);

            try {
              // Query project metadata to find the Stage field and its "Blocked" option
              const projectQuery = await github.graphql(`
                query($org: String!, $number: Int!) {
                  organization(login: $org) {
                    projectV2(number: $number) {
                      id
                      fields(first: 20) {
                        nodes {
                          ... on ProjectV2SingleSelectField {
                            id
                            name
                            options { id name }
                          }
                        }
                      }
                    }
                  }
                }
              `, { org: orgLogin, number: projectNumber });

              const project = projectQuery.organization?.projectV2;
              if (!project) {
                console.log(`Project #${projectNumber} not found. Skipping blocked update.`);
                return;
              }
              const projectId = project.id;

              let stageFieldId = null, blockedOptionId = null;
              for (const field of project.fields.nodes) {
                if (field.name === 'Stage') {
                  stageFieldId = field.id;
                  const opt = (field.options || []).find((o) => o.name === 'Blocked');
                  if (opt) blockedOptionId = opt.id;
                }
              }

              if (!stageFieldId || !blockedOptionId) {
                console.log("Stage field or 'Blocked' option not found. Skipping.");
                return;
              }

              // Find the project item for this issue
              const issueQuery = await github.graphql(`
                query($id: ID!) {
                  node(id: $id) {
                    ... on Issue {
                      projectItems(first: 10) {
                        nodes {
                          id
                          project { id }
                        }
                      }
                    }
                  }
                }
              `, { id: issueNodeId });

              const items = issueQuery.node?.projectItems?.nodes || [];
              const existing = items.find((item) => item.project.id === projectId);
              let itemId = existing?.id;

              if (!itemId) {
                // Add the issue to the project so we can mark it blocked
                const addResult = await github.graphql(`
                  mutation($projectId: ID!, $contentId: ID!) {
                    addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                      item { id }
                    }
                  }
                `, { projectId, contentId: issueNodeId });
                itemId = addResult.addProjectV2ItemById?.item?.id;
              }

              if (!itemId) {
                console.log('Could not obtain project item ID. Skipping blocked update.');
                return;
              }

              // Set Stage to "Blocked"
              await github.graphql(`
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { singleSelectOptionId: $optionId }
                  }) { projectV2Item { id } }
                }
              `, { projectId, itemId, fieldId: stageFieldId, optionId: blockedOptionId });
              console.log("Stage field updated to 'Blocked'.");
            } catch (err) {
              console.log(`Project board blocked update failed (non-fatal): ${err.message}`);
            }
